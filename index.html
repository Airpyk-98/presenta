<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Presenta by MAHADUMIA</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

    <!-- Panzoom (For smooth Pinch & Zoom gestures) -->
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        brand: { orange: '#f97316', dark: '#000000', light: '#ffffff' }
                    }
                }
            }
        }
    </script>

    <style>
        body { overscroll-behavior-y: none; touch-action: none; -webkit-tap-highlight-color: transparent; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        canvas { user-select: none; -webkit-user-select: none; }
        
        /* Smooth UI Transitions */
        .ui-transition { transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .ui-hidden-top { transform: translateY(-100%); }
        .ui-hidden-bottom { transform: translateY(100%); }
    </style>
</head>
<body class="bg-gray-900 text-brand-dark h-screen w-screen flex flex-col overflow-hidden font-sans relative">

    <!-- ================= UI OVERLAY (Auto-Hides) ================= -->
    <div id="ui-layer" class="absolute inset-0 pointer-events-none flex flex-col justify-between z-50 overflow-hidden">
        
        <!-- Top Bar Group -->
        <div id="top-bar" class="ui-transition pointer-events-auto">
            <!-- Header -->
            <header class="bg-brand-dark text-brand-light h-14 flex justify-between items-center px-4 flex-shrink-0 shadow-md">
                <div class="flex items-center gap-2">
                    <i class="fa-solid fa-layer-group text-brand-orange text-xl"></i>
                    <h1 class="text-brand-orange font-bold text-xl tracking-wide">
                        Presenta <span class="text-xs font-light text-gray-300 ml-1">by MAHADUMIA</span>
                    </h1>
                </div>
                <div>
                    <button id="add-pdf-btn" class="bg-brand-orange hover:bg-orange-600 text-white px-4 py-1.5 rounded shadow-sm flex items-center gap-2 active:scale-95 transition-transform">
                        <i class="fa-solid fa-plus"></i> <span class="hidden sm:inline font-semibold">Open PDF</span>
                    </button>
                    <input type="file" id="pdf-upload" accept="application/pdf" class="hidden">
                </div>
            </header>

            <!-- Tabs Navigation -->
            <nav class="bg-gray-100 border-b border-gray-300 h-12 flex items-center px-2 hide-scrollbar overflow-x-auto shadow-sm" id="tab-bar">
                <!-- Tabs injected here -->
            </nav>
        </div>

        <!-- Bottom Bar Group -->
        <div id="bottom-bar" class="ui-transition pointer-events-auto bg-brand-dark/95 backdrop-blur shadow-[0_-5px_20px_rgba(0,0,0,0.3)] w-full h-16 flex justify-center items-center px-2">
            
            <!-- PDF Controls -->
            <div id="controls-pdf" class="hidden flex items-center gap-6 text-white w-full max-w-md justify-between px-4">
                <button id="pdf-prev" class="w-12 h-12 rounded-full bg-brand-orange hover:bg-orange-600 flex items-center justify-center disabled:opacity-50 text-xl shadow-lg active:scale-90 transition-transform"><i class="fa-solid fa-chevron-left"></i></button>
                <div id="pdf-info" class="font-bold tracking-widest text-lg bg-black/50 px-4 py-1 rounded-full border border-gray-600">1 / 1</div>
                <button id="pdf-next" class="w-12 h-12 rounded-full bg-brand-orange hover:bg-orange-600 flex items-center justify-center disabled:opacity-50 text-xl shadow-lg active:scale-90 transition-transform"><i class="fa-solid fa-chevron-right"></i></button>
            </div>

            <!-- Whiteboard Controls -->
            <div id="controls-wb" class="hidden flex items-center justify-evenly w-full max-w-lg gap-2 overflow-x-auto hide-scrollbar px-2">
                <!-- Undo/Redo -->
                <button id="wb-undo" class="w-10 h-10 rounded-full bg-gray-700 text-white flex items-center justify-center active:scale-90 transition-transform disabled:opacity-30"><i class="fa-solid fa-rotate-left"></i></button>
                <button id="wb-redo" class="w-10 h-10 rounded-full bg-gray-700 text-white flex items-center justify-center active:scale-90 transition-transform disabled:opacity-30"><i class="fa-solid fa-rotate-right"></i></button>
                
                <div class="w-px h-8 bg-gray-600 mx-1"></div>
                
                <!-- Colors -->
                <button class="w-9 h-9 rounded-full bg-white color-btn ring-2 ring-brand-orange ring-offset-2 ring-offset-brand-dark" data-color="#ffffff"></button>
                <button class="w-9 h-9 rounded-full bg-brand-orange color-btn border border-transparent" data-color="#f97316"></button>
                <button class="w-9 h-9 rounded-full bg-blue-500 color-btn border border-transparent" data-color="#3b82f6"></button>
                <button class="w-9 h-9 rounded-full bg-green-500 color-btn border border-transparent" data-color="#22c55e"></button>
                
                <div class="w-px h-8 bg-gray-600 mx-1"></div>

                <!-- Tools -->
                <button id="wb-eraser" class="w-10 h-10 rounded-full bg-gray-700 text-white flex items-center justify-center active:scale-90 transition-transform"><i class="fa-solid fa-eraser"></i></button>
                <button id="wb-clear" class="w-10 h-10 rounded-full bg-red-600 text-white flex items-center justify-center active:scale-90 transition-transform"><i class="fa-solid fa-trash"></i></button>
            </div>
            
        </div>
    </div>

    <!-- Hidden trigger zone to bring UI back up -->
    <div id="ui-reveal-trigger" class="absolute bottom-0 left-0 right-0 h-20 z-40"></div>

    <!-- ================= MAIN WORKSPACE ================= -->
    <main id="workspace" class="absolute inset-0 bg-gray-900 overflow-hidden z-10">
        
        <!-- Whiteboard View -->
        <div id="view-whiteboard" class="absolute inset-0 bg-gray-900 view-container" style="display: block;">
            <canvas id="wb-canvas" class="absolute top-0 left-0 w-full h-full cursor-crosshair touch-none"></canvas>
        </div>

        <!-- PDF Views appended here dynamically -->
    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // ==========================================
        // STATE MANAGEMENT
        // ==========================================
        const state = {
            tabs: [{ id: 'whiteboard', title: 'Whiteboard', type: 'whiteboard', icon: 'fa-pen-to-square' }],
            activeTabId: 'whiteboard',
            pdfs: {},
            whiteboard: {
                isDrawing: false,
                color: '#ffffff', // Default white ink for dark mode whiteboard
                isEraser: false,
                size: 4,
                paths: [], // Vector paths for memory-safe undo
                redoPaths: [],
                currentPath: null
            },
            ui: { isVisible: true, timeout: null }
        };

        // DOM Elements
        const tabBar = document.getElementById('tab-bar');
        const workspace = document.getElementById('workspace');
        const pdfUploadInput = document.getElementById('pdf-upload');
        const addPdfBtn = document.getElementById('add-pdf-btn');
        
        // UI Overlay Elements
        const topBar = document.getElementById('top-bar');
        const bottomBar = document.getElementById('bottom-bar');
        const controlsPdf = document.getElementById('controls-pdf');
        const controlsWb = document.getElementById('controls-wb');
        const revealTrigger = document.getElementById('ui-reveal-trigger');

        // ==========================================
        // IMMERSIVE UI LOGIC
        // ==========================================
        function resetUITimer() {
            clearTimeout(state.ui.timeout);
            if (state.ui.isVisible) {
                state.ui.timeout = setTimeout(hideUI, 5000);
            }
        }

        function showUI() {
            state.ui.isVisible = true;
            topBar.classList.remove('ui-hidden-top');
            bottomBar.classList.remove('ui-hidden-bottom');
            revealTrigger.style.pointerEvents = 'none'; // Disable trigger when UI is visible
            resetUITimer();
        }

        function hideUI() {
            if (state.whiteboard.isDrawing) return; // Don't hide while actively drawing
            state.ui.isVisible = false;
            topBar.classList.add('ui-hidden-top');
            bottomBar.classList.add('ui-hidden-bottom');
            revealTrigger.style.pointerEvents = 'auto'; // Enable trigger to show UI
        }

        // Tap bottom edge to reveal
        revealTrigger.addEventListener('click', showUI);
        revealTrigger.addEventListener('touchstart', showUI, {passive: true});

        // Any interaction with UI resets the hide timer
        topBar.addEventListener('touchstart', resetUITimer, {passive: true});
        bottomBar.addEventListener('touchstart', resetUITimer, {passive: true});
        topBar.addEventListener('mousemove', resetUITimer, {passive: true});
        
        // ==========================================
        // TAB MANAGEMENT
        // ==========================================
        function renderTabs() {
            tabBar.innerHTML = '';
            state.tabs.forEach(tab => {
                const isActive = tab.id === state.activeTabId;
                const tabEl = document.createElement('div');
                
                const baseClasses = "flex items-center gap-2 px-5 py-2.5 mx-1 rounded-t-lg cursor-pointer transition-all min-w-max select-none";
                const activeClasses = "bg-brand-dark text-white border-t-4 border-brand-orange font-bold shadow-lg transform scale-105 z-10";
                const inactiveClasses = "bg-gray-300 text-gray-700 hover:bg-gray-400 font-medium";
                
                tabEl.className = `${baseClasses} ${isActive ? activeClasses : inactiveClasses}`;
                tabEl.onclick = () => switchTab(tab.id);

                tabEl.innerHTML = `
                    <i class="fa-solid ${tab.icon} ${isActive ? 'text-brand-orange' : 'text-gray-500'}"></i>
                    <span>${tab.title.length > 15 ? tab.title.substring(0, 15) + '...' : tab.title}</span>
                `;

                if (tab.type !== 'whiteboard') {
                    const closeBtn = document.createElement('button');
                    closeBtn.innerHTML = '<i class="fa-solid fa-xmark"></i>';
                    closeBtn.className = "ml-3 w-6 h-6 rounded-full flex items-center justify-center bg-black/10 hover:bg-red-500 hover:text-white transition-colors";
                    closeBtn.onclick = (e) => { e.stopPropagation(); closeTab(tab.id); };
                    tabEl.appendChild(closeBtn);
                }

                tabBar.appendChild(tabEl);
            });
            
            // Update Bottom Toolbar Content
            if (state.activeTabId === 'whiteboard') {
                controlsPdf.classList.add('hidden');
                controlsWb.classList.remove('hidden');
                controlsWb.classList.add('flex');
            } else {
                controlsWb.classList.add('hidden');
                controlsWb.classList.remove('flex');
                controlsPdf.classList.remove('hidden');
                updatePdfControlsUI(state.activeTabId);
            }
            
            resetUITimer();
        }

        function switchTab(tabId) {
            state.activeTabId = tabId;
            renderTabs();

            document.querySelectorAll('.view-container').forEach(view => view.style.display = 'none');
            
            const activeView = document.getElementById(`view-${tabId}`);
            if (activeView) activeView.style.display = 'block';

            if (tabId === 'whiteboard') resizeWhiteboard();
            else if (state.pdfs[tabId]) renderPdfPage(tabId, state.pdfs[tabId].pageNum);
        }

        function closeTab(tabId) {
            document.getElementById(`view-${tabId}`)?.remove();
            state.tabs = state.tabs.filter(t => t.id !== tabId);
            delete state.pdfs[tabId];
            if (state.activeTabId === tabId) switchTab('whiteboard');
            else renderTabs();
        }

        // ==========================================
        // PDF HANDLING & PINCH-ZOOM
        // ==========================================
        addPdfBtn.addEventListener('click', () => pdfUploadInput.click());

        pdfUploadInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            e.target.value = '';

            const fileReader = new FileReader();
            addPdfBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
            
            fileReader.onload = async function() {
                try {
                    const typedarray = new Uint8Array(this.result);
                    const pdfDoc = await pdfjsLib.getDocument({data: typedarray}).promise;
                    const tabId = 'pdf-' + Date.now();
                    
                    state.tabs.push({ id: tabId, title: file.name.replace('.pdf', ''), type: 'pdf', icon: 'fa-file-pdf' });
                    state.pdfs[tabId] = { doc: pdfDoc, pageNum: 1, totalPages: pdfDoc.numPages, isRendering: false, panzoomInstance: null };

                    createPdfViewDOM(tabId);
                    switchTab(tabId);
                } catch (err) {
                    alert("Error loading PDF");
                } finally {
                    addPdfBtn.innerHTML = '<i class="fa-solid fa-plus"></i> <span class="hidden sm:inline font-semibold">Open PDF</span>';
                }
            };
            fileReader.readAsArrayBuffer(file);
        });

        function createPdfViewDOM(tabId) {
            const viewDiv = document.createElement('div');
            viewDiv.id = `view-${tabId}`;
            viewDiv.className = 'absolute inset-0 bg-black view-container flex justify-center items-center overflow-hidden';
            viewDiv.style.display = 'none';

            // Wrapper is crucial for the panzoom library to work securely
            const canvasWrapper = document.createElement('div');
            canvasWrapper.id = `pdf-wrap-${tabId}`;
            canvasWrapper.className = 'w-full h-full flex justify-center items-center touch-none';

            const canvas = document.createElement('canvas');
            canvas.id = `pdf-canvas-${tabId}`;
            canvas.className = 'shadow-2xl';
            
            canvasWrapper.appendChild(canvas);
            viewDiv.appendChild(canvasWrapper);
            workspace.appendChild(viewDiv);

            // Initialize Panzoom for pinch-to-zoom
            const pz = panzoom(canvas, {
                maxZoom: 5,
                minZoom: 1,
                bounds: true,
                boundsPadding: 0,
                smoothScroll: false
            });
            state.pdfs[tabId].panzoomInstance = pz;
            
            // Tapping PDF toggles Immersive Mode
            canvasWrapper.addEventListener('click', () => {
                if(state.ui.isVisible) hideUI(); else showUI();
            });
        }

        async function renderPdfPage(tabId, num) {
            const pdfState = state.pdfs[tabId];
            const canvas = document.getElementById(`pdf-canvas-${tabId}`);
            const wrapper = document.getElementById(`pdf-wrap-${tabId}`);
            if (!pdfState || !canvas) return;

            pdfState.isRendering = true;
            pdfState.pageNum = num;
            
            // Reset zoom before rendering new page
            if(pdfState.panzoomInstance) {
                pdfState.panzoomInstance.moveTo(0, 0);
                pdfState.panzoomInstance.zoomAbs(0, 0, 1);
            }

            try {
                const page = await pdfState.doc.getPage(num);
                const unscaledViewport = page.getViewport({ scale: 1.0 });
                
                // Calculate Fit-To-Screen for Landscape/Portrait
                const scaleX = wrapper.clientWidth / unscaledViewport.width;
                const scaleY = wrapper.clientHeight / unscaledViewport.height;
                const fitScale = Math.min(scaleX, scaleY);

                // Render at higher resolution for crispness when user zooms in
                const outputScale = window.devicePixelRatio || 1;
                const renderScale = fitScale * outputScale * 1.5; // 1.5x boost
                
                const viewport = page.getViewport({ scale: renderScale });
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                // CSS size forces it to fit screen exact dimensions
                canvas.style.width = `${unscaledViewport.width * fitScale}px`;
                canvas.style.height = `${unscaledViewport.height * fitScale}px`;

                await page.render({
                    canvasContext: canvas.getContext('2d'),
                    viewport: viewport
                }).promise;

                updatePdfControlsUI(tabId);
            } catch (err) {
                console.log(err);
            } finally {
                pdfState.isRendering = false;
            }
        }

        function updatePdfControlsUI(tabId) {
            if (state.activeTabId !== tabId || state.tabs.find(t=>t.id === tabId).type !== 'pdf') return;
            const pdf = state.pdfs[tabId];
            document.getElementById('pdf-info').textContent = `${pdf.pageNum} / ${pdf.totalPages}`;
            document.getElementById('pdf-prev').disabled = pdf.pageNum <= 1;
            document.getElementById('pdf-next').disabled = pdf.pageNum >= pdf.totalPages;
        }

        // Global PDF Controls Listeners
        document.getElementById('pdf-prev').onclick = () => {
            const pdf = state.pdfs[state.activeTabId];
            if(pdf && !pdf.isRendering && pdf.pageNum > 1) renderPdfPage(state.activeTabId, pdf.pageNum - 1);
            resetUITimer();
        };
        document.getElementById('pdf-next').onclick = () => {
            const pdf = state.pdfs[state.activeTabId];
            if(pdf && !pdf.isRendering && pdf.pageNum < pdf.totalPages) renderPdfPage(state.activeTabId, pdf.pageNum + 1);
            resetUITimer();
        };


        // ==========================================
        // WHITEBOARD & VECTOR DRAWING
        // ==========================================
        const wbCanvas = document.getElementById('wb-canvas');
        const wbCtx = wbCanvas.getContext('2d');
        const wbContainer = document.getElementById('view-whiteboard');

        // Setup Toolbar actions
        const colorBtns = document.querySelectorAll('.color-btn');
        const btnEraser = document.getElementById('wb-eraser');
        const btnUndo = document.getElementById('wb-undo');
        const btnRedo = document.getElementById('wb-redo');
        const btnClear = document.getElementById('wb-clear');

        function updateWbButtons() {
            btnUndo.disabled = state.whiteboard.paths.length === 0;
            btnRedo.disabled = state.whiteboard.redoPaths.length === 0;
            
            // Highlight eraser
            if(state.whiteboard.isEraser) {
                btnEraser.classList.replace('bg-gray-700', 'bg-brand-orange');
                colorBtns.forEach(b => b.classList.remove('ring-2', 'ring-brand-orange', 'ring-offset-2', 'ring-offset-brand-dark'));
            } else {
                btnEraser.classList.replace('bg-brand-orange', 'bg-gray-700');
            }
        }

        colorBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                state.whiteboard.isEraser = false;
                state.whiteboard.color = e.currentTarget.dataset.color;
                
                colorBtns.forEach(b => {
                    b.classList.remove('ring-2', 'ring-brand-orange', 'ring-offset-2', 'ring-offset-brand-dark', 'border-transparent');
                    if(b !== e.currentTarget) b.classList.add('border-transparent');
                });
                e.currentTarget.classList.add('ring-2', 'ring-brand-orange', 'ring-offset-2', 'ring-offset-brand-dark');
                e.currentTarget.classList.remove('border-transparent');
                updateWbButtons();
                resetUITimer();
            });
        });

        btnEraser.addEventListener('click', () => {
            state.whiteboard.isEraser = true;
            updateWbButtons();
            resetUITimer();
        });

        btnClear.addEventListener('click', () => {
            state.whiteboard.paths = [];
            state.whiteboard.redoPaths = [];
            redrawWhiteboard();
            resetUITimer();
        });

        btnUndo.addEventListener('click', () => {
            if (state.whiteboard.paths.length > 0) {
                state.whiteboard.redoPaths.push(state.whiteboard.paths.pop());
                redrawWhiteboard();
            }
            resetUITimer();
        });

        btnRedo.addEventListener('click', () => {
            if (state.whiteboard.redoPaths.length > 0) {
                state.whiteboard.paths.push(state.whiteboard.redoPaths.pop());
                redrawWhiteboard();
            }
            resetUITimer();
        });

        function resizeWhiteboard() {
            if (state.activeTabId !== 'whiteboard') return;
            wbCanvas.width = wbContainer.clientWidth;
            wbCanvas.height = wbContainer.clientHeight;
            redrawWhiteboard();
        }

        function redrawWhiteboard() {
            wbCtx.clearRect(0, 0, wbCanvas.width, wbCanvas.height);
            wbCtx.lineCap = 'round';
            wbCtx.lineJoin = 'round';

            state.whiteboard.paths.forEach(p => {
                wbCtx.beginPath();
                if (p.isEraser) {
                    wbCtx.globalCompositeOperation = 'destination-out';
                    wbCtx.lineWidth = 30; // Eraser size
                } else {
                    wbCtx.globalCompositeOperation = 'source-over';
                    wbCtx.strokeStyle = p.color;
                    wbCtx.lineWidth = p.size;
                }
                
                if (p.points.length > 0) {
                    wbCtx.moveTo(p.points[0].x, p.points[0].y);
                    for(let i = 1; i < p.points.length; i++) {
                        wbCtx.lineTo(p.points[i].x, p.points[i].y);
                    }
                    wbCtx.stroke();
                }
            });
            updateWbButtons();
        }

        function getCoords(e) {
            const rect = wbCanvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
            }
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        }

        function startDrawing(e) {
            if (e.target !== wbCanvas || e.touches?.length > 1) return;
            e.preventDefault();
            
            // Interaction handles immersive mode
            clearTimeout(state.ui.timeout);
            
            state.whiteboard.isDrawing = true;
            const pt = getCoords(e);
            
            state.whiteboard.currentPath = {
                color: state.whiteboard.color,
                size: state.whiteboard.size,
                isEraser: state.whiteboard.isEraser,
                points: [pt]
            };

            // Setup real-time drawing context
            wbCtx.beginPath();
            if (state.whiteboard.isEraser) {
                wbCtx.globalCompositeOperation = 'destination-out';
                wbCtx.lineWidth = 30;
            } else {
                wbCtx.globalCompositeOperation = 'source-over';
                wbCtx.strokeStyle = state.whiteboard.color;
                wbCtx.lineWidth = state.whiteboard.size;
            }
            wbCtx.lineCap = 'round';
            wbCtx.lineJoin = 'round';
            wbCtx.moveTo(pt.x, pt.y);
            wbCtx.lineTo(pt.x, pt.y); // Draw dot on click
            wbCtx.stroke();
        }

        function draw(e) {
            if (!state.whiteboard.isDrawing) return;
            e.preventDefault();
            const pt = getCoords(e);
            
            state.whiteboard.currentPath.points.push(pt);
            wbCtx.lineTo(pt.x, pt.y);
            wbCtx.stroke();
        }

        function stopDrawing() {
            if (state.whiteboard.isDrawing) {
                state.whiteboard.isDrawing = false;
                if (state.whiteboard.currentPath) {
                    state.whiteboard.paths.push(state.whiteboard.currentPath);
                    state.whiteboard.redoPaths = []; // Clear redo history on new action
                    state.whiteboard.currentPath = null;
                }
                updateWbButtons();
                resetUITimer(); // restart the UI hide timer
            }
        }

        // Mouse Events
        wbCanvas.addEventListener('mousedown', startDrawing);
        wbCanvas.addEventListener('mousemove', draw);
        wbCanvas.addEventListener('mouseup', stopDrawing);
        wbCanvas.addEventListener('mouseout', stopDrawing);

        // Touch Events
        wbCanvas.addEventListener('touchstart', startDrawing, { passive: false });
        wbCanvas.addEventListener('touchmove', draw, { passive: false });
        wbCanvas.addEventListener('touchend', stopDrawing);
        wbCanvas.addEventListener('touchcancel', stopDrawing);

        // ==========================================
        // INITIALIZATION & RESIZE HANDLING
        // ==========================================
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (state.activeTabId === 'whiteboard') resizeWhiteboard();
                else if (state.pdfs[state.activeTabId]) renderPdfPage(state.activeTabId, state.pdfs[state.activeTabId].pageNum);
            }, 300);
        });

        window.addEventListener('DOMContentLoaded', () => {
            renderTabs();
            setTimeout(() => {
                resizeWhiteboard();
                showUI(); // Starts the auto-hide timer naturally
            }, 100); 
        });

    </script>
</body>
</html>
